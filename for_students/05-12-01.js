// @ts-check
/* jshint -W069, esversion:6 */

/**
 * drawing function for box 1
 *
 * draw something.
 **/

// note that checking that canvas is the right type of element tells typescript
// that this is the right type - it's a form of a safe cast 
let canvas = document.getElementById("canvas1");
if (!(canvas instanceof HTMLCanvasElement))
    throw new Error("Canvas is not HTML Element");

let context = canvas.getContext("2d");

let totDist = 0; //total distance travelled along curve
let ptDistList = []; //list of points for the 20 dots on curve
//the original points given to us by the workbook
let points = [
    [50, 150],
    [350, 150],
    [350, 50],
    [200, 100],
    [50, 50]
];

//draw the actual curve (not the points)
context.lineWidth = 3;
context?.beginPath();
context?.moveTo(points[0][0], points[0][1]);
for (let i = 0; i < points.length; i++) {
    let p0 = points[((i - 1) + points.length) % points.length];
    let p1 = points[i];
    let p2 = points[(i + 1) % points.length];
    let p3 = points[(i + 2) % points.length];
    let cp1 = calcControlPoints(p0, p1, p2, p3)[0];
    let cp2 = calcControlPoints(p0, p1, p2, p3)[1];
    context?.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]);
}
context?.closePath();
context?.stroke();
getDistOfCurve();

let seg = 0;
//find all points, distances, and actually draw the 20 points (main part of point drawing code)
for (let i = 0; i < 20; i++) {
    let currCurveDist = (i * totDist / 20);
    for (let j = 0; j < ptDistList.length; j++) {
        if (currCurveDist > ptDistList[j] && currCurveDist < ptDistList[j + 1]) {
            seg = j;
        }
    }
    let ptDist = ptDistList[seg + 1] - ptDistList[seg]
    let distRatio = (currCurveDist - ptDistList[seg]) / ptDist;
    let p0 = points[((seg - 1) + points.length) % points.length];
    let p1 = points[seg];
    let p2 = points[(seg + 1) % points.length];
    let p3 = points[(seg + 2) % points.length];
    let cp1 = calcControlPoints(p0, p1, p2, p3)[0];
    let cp2 = calcControlPoints(p0, p1, p2, p3)[1];
    let currPos = cubicBezierForm(p1, cp1, cp2, p2, distRatio);
    drawPointsOnCurve(currPos[0], currPos[1]); 
}

/**
 * function to calculate the two control points that will be used in drawing the
 * bezier curve ; calculated using CP1 = p1 + (p2-p0) / 6 and CP2 = p2 - (p3-p1) / 6
 * 
 * @param {*} p0 
 * @param {*} p1 
 * @param {*} p2 
 * @param {*} p3 
 * @returns control point 1 and 2
 */
function calcControlPoints(p0, p1, p2, p3) {
    let cp1 = [
        p1[0] + (p2[0] - p0[0]) / 6,
        p1[1] + (p2[1] - p0[1]) / 6
    ];
    let cp2 = [
        p2[0] - (p3[0] - p1[0]) / 6,
        p2[1] - (p3[1] - p1[1]) / 6
    ];
    return [cp1, cp2];
}

/**
 * This function is used to calculate the position of a point along the cubic Bezier curve
 * Although the code is not generated by chatGPT, when prompted which form / equation I should
 * use for calculating how far along on the curve we are, chatGPT provided that I should use
 * the cubic Bezier form which is what this function uses. (https://blog.maximeheckel.com/posts/cubic-bezier-from-math-to-motion/)
 * 
 * @param {*} p1 
 * @param {*} cp1 
 * @param {*} cp2 
 * @param {*} p2 
 * @param {*} t 
 * @returns the position of the point along the cubic bezier curve at given t
 */
function cubicBezierForm(p1, cp1, cp2, p2, t) {
    let x = Math.pow(1 - t, 3) * p1[0] + 3 * Math.pow(1 - t, 2) * t * cp1[0] + 3 * (1 - t) * t * t * cp2[0] + Math.pow(t, 3) * p2[0];
    let y = Math.pow(1 - t, 3) * p1[1] + 3 * Math.pow(1 - t, 2) * t * cp1[1] + 3 * (1 - t) * t * t * cp2[1] + Math.pow(t, 3) * p2[1];
    return [x, y];
}

/**
 * function to actually draw the ellipses (20 dots) along the curve. x and y will
 * be passed into this function based on how far along we are on the curve.
 * 
 * @param {*} x 
 * @param {*} y 
 */
function drawPointsOnCurve(x, y) {
    context.fillStyle = "#7ba874";
    context?.beginPath();
    context?.ellipse(x, y, 6, 6, 0, 0, Math.PI * 2);
    context?.fill();
}

/**
 * this function calculates the cumulative distance we have travelled along the curve. it does
 * not return anything, but rather adds the actual points to the list (using the cubicbezierform),
 * and calculates total distance travelled along the curve.
 */
function getDistOfCurve() {
    let step = 0.001;
    ptDistList.push(0);
    for (let i = 0; i < points.length; i++) {
        let p0 = points[((i - 1) + points.length) % points.length];
        let p1 = points[i];
        let p2 = points[(i + 1) % points.length];
        let p3 = points[(i + 2) % points.length];
        let prevPoint;
        let ptDist = 0;
        for (let j = 0; j <= 1; j += step) {
            let point = cubicBezierForm(p1, calcControlPoints(p0, p1, p2, p3)[0], calcControlPoints(p0, p1, p2, p3)[1], p2, j);
            if (prevPoint != null) {
                //distance formula
                ptDist += Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2));
            }
            prevPoint = point;
        }
        ptDistList.push(ptDist + totDist);
        //move farther along on the curve (add new distance to the total distance)
        totDist += ptDist;
    }
}
